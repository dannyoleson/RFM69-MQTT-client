// RFM69 DHT node sketch
//
// This node talks to the MQTT-Gateway and will:
// - send sensor data periodically and on-demand
// - receive commands from the gateway to control actuators
// - receive commands from the gateway to change settings
//
// Several nodes can operate within a single network; each have a unique node ID.
// On startup the node operates with default values, set on compilation.
//
// Hardware used is a 3.3 Volt 8MHz arduino Pro; this is easier to interface to RFM69 
//
// A DHT-11 is used for temperature & humidity measurements, other sensors and outputs can be added easily.
//
// Message format is: nodeID/deviceID/command/integer/float/string
//
// Depending on the type of data (integer, float or string) one of the payload variables is used
// Command = 0 means write a value in the node, cmd = 1 means read a value 
//
// Current defined devices are:
//
//	0	uptime:			read uptime node in minutes
//	1	node:			read/set transmission interval in seconds, 0 means no periodic transmission
//	2	RSSI:			read radio signal strength
//	3	Version:		read version node software
//	4	voltage:		read battery level
//	5	ACK:			read/set acknowledge message after a 'set' request
//	6	toggle:			read/set toggle function on button press
//	7	timer:			read/set activation timer after button press in seconds, 0 means no timer
//	
//	16	actuator:		read/set LED or relay output
//	40	Button:			tx only: message sent when button pressed
//	48	temperature:		read temperature
//	49	humidity:		read humidity
//  64  light:			read light level
//  65  flame:			read flame sensor
//	66  gas:			read gas sensor
//	90	error:			tx only: error message if no wireless connection (generated by gateway)
//	92	error:			tx only: device not supported
//	99	wakeup:			tx only: first message sent on node startup
//
// 	The button can be set to:
//	- generate a message on each press (limited to one per 10 seconds) and/or
//	- toggle the output ACT1 (local node function) or
//	- activate the output for a fixed time period (local node function)
//
//	A debug mode is included which outputs messages on the serial output
//
//	RFM69 Library by Felix Rusu - felix@lowpowerlab.com
//	Get the RFM69 library at: https://github.com/LowPowerLab/
//
//	version 1.7 by Computourist@gmail.com december 2014
//	version 2.0 increased payload size; implemented node uptime; standard device type convention; error handling .
//	version 2.1 removed device 8; changed handling of device 40; compatible with gateway V2.2	; march 2015

#include "NodeSystemData.h"
#include "RealInputData.h"
#include "DigitalInputData.h"
#include "AnalogOutputData.h"
#include "DigitalOutputData.h"
#include "AnalogSensorData.h"
#include "ComponentData.h"
#include <RFM69.h>
#include <SPI.h>
#include <DHT.h>

//
// CONFIGURATION PARAMETERS
//
#define NODEID 2 					// unique node ID within the closed network
#define GATEWAYID 1					// node ID of the Gateway is always 1
#define NETWORKID 100					// network ID of the network
#define ENCRYPTKEY "5029386215036408" 			// 16-char encryption key; same as on Gateway!
#define DEBUG						// uncomment for debugging
#define VERSION "DHT V2.2"				// this value can be queried as device 3

// device ID ranges
#define NODESYSTEMDEVICERANGEBOTTOM 0
#define NODESYSTEMDEVICERANGETOP 15
#define ISNODESYSTEMDEVICE(x) x >= NODESYSTEMDEVICERANGEBOTTOM && x <= NODESYSTEMDEVICERANGETOP

#define DIGITALOUTPUTRANGEBOTTOM 16
#define DIGITALOUTPUTRANGETOP 31
#define ISDIGITALOUTPUTDEVICE(x) x >= DIGITALOUTPUTRANGEBOTTOM && x <= DIGITALOUTPUTRANGETOP

#define ANALOGOUTPUTRANGEBOTTOM 32
#define ANALOGOUTPUTRANGETOP 39
#define ISANALOGOUTPUTDEVICE(x) x >= ANALOGOUTPUTRANGEBOTTOM && x <= ANALOGOUTPUTRANGETOP

#define DIGITALINPUTRANGEBOTTOM 40
#define DIGITALINPUTRANGETOP 47
#define ISDIGITALINPUTSENSOR(x) x >= DIGITALINPUTRANGEBOTTOM && x <= DIGITALINPUTRANGETOP

#define REALINPUTRANGEBOTTOM 48
#define REALINPUTRANGETOP 63
#define ISREALINPUTSENSOR(x) x >= REALINPUTRANGEBOTTOM && x <= REALINPUTRANGETOP

#define ANALOGSENSORRANGEBOTTOM 64
#define ANALOGSENSORRANGETOP 71
#define ISANALOGSENSOR(x) x >= ANALOGSENSORRANGEBOTTOM && x <= ANALOGSENSORRANGETOP

#define ERRORCODEBOTTOM 90
#define ERRORCODETOP 98
#define ISERRORCODE(x) x >= ERRORCODEBOTTOM && x <= ERRORCODETOP

// just one device - no need for top/bottom
#define ISWAKEUPCODE(x) x == 99

// Wireless settings	Match frequency to the hardware version of the radio
#define FREQUENCY RF69_433MHZ
//#define FREQUENCY RF69_868MHZ
//#define FREQUENCY RF69_915MHZ

#define IS_RFM69HW 					// uncomment only for RFM69HW! 
#define ACK_TIME 100					// max # of ms to wait for an ack

// defining NODESYSTEMDEVICES - not devices as such, but we treat them like devices to keep the code simple
#define UPTIMEDEVICEID 0
#define TXINTERVALDEVICEID 1
#define RSSIDEVICEID 2
#define VERSIONDEVICEID 3
#define VOLTAGEDEVICEID 4
#define ACKDEVICEID 5
#define TOGGLEDEVICEID 6
#define TIMERDEVICEID 7

// Binary input settings
#define BTN 8						// Button pin
#define BTNDEVICEID 40

// Binary output settings
#define ACT1 9						// Actuator pin (LED or relay)
#define ACTUATORDEVICEID 16

// Analog sensor settings
#define LIGHTPIN A0
#define LIGHTSENSORDEVICEID 64
#define FLAMEPIN A1
#define FLAMESENSORDEVICEID 65
#define GASPIN A2
#define GASSENSORDEVICEID 66

// DHT sensor setting
#define DHTPIN 4					// DHT data connection
#define DHTTEMPDEVICEID 48
#define DHTHUMIDITYDEVICEID 49
#define	DHTTYPE	DHT22					// type of sensor

// Misc devices
#define WIRELESSCONNECTIONERROR 90
#define UNSUPPORTEDDEVICE 92
#define WAKEUPNODE 99

#define SERIAL_BAUD 115200


//
//	STARTUP DEFAULTS
//
long 	txInterval = 20*1000;				// periodic transmission interval in ms
long	timeInterval = 20*1000;				// timer interval in ms
bool	toggleOnButton = true;				// toggle output on button press

											//
											//	VARIABLES
											//
//long	lastPeriod = -1;				// timestamp last transmission
//long 	lastBtnPress = -1;				// timestamp last buttonpress
//long	lastMinute = -1;				// timestamp last minute
//long	upTime = 0;					// uptime in minutes
//float	hum, temp;					// humidity, temperature
//int		ACT1State;					// status ACT1 output
//int		signalStrength;					// radio signal strength
bool	setAck = false;					// send ACK message on 'SET' request
//bool	send0, send1, send2, send3, send4;
//bool	send5, send6, send7;
//bool	send16, send40, send48, send49, send92;		// message triggers
bool	promiscuousMode = false; 			// only listen to nodes within the closed network
//bool	curState = true;				// current button state
//bool	lastState = true;				// last button state
bool	timerOnButton = false;				// timer output on button press
//bool	msgBlock = false;				// flag to hold button messages to prevent overload



typedef struct {					// Radio packet format
	int		nodeID;						// node identifier
	int		devID;						// device identifier 
	int		cmd;						// read or write
	long	intVal;						// integer payload
	float	fltVal;						// floating payload
	char	payLoad[32];					// string payload
} Message;

Message mes;

//DHT dht(DHTPIN, DHTTYPE, 3);			// initialise temp/humidity sensor for 3.3 Volt arduino
DHT dht(DHTPIN, DHTTYPE);				// 5 volt power
RFM69 radio;

// values used by sensors to check their states
/*
typedef struct {
	int		pollInterval = 2 * 1000;
	long	lastPollTime = -1;
	int		lastLevel = -1;
	int		deltaThreshold = 20; // +/- this delta will trigger a transmission of data
	int		devID = -1;
	bool	shouldSend = false;
} AnalogSensor;
*/

// adding components in setup() will add to this array and increment the count
ComponentDataClass *connectedComponents[100];
int connectedComponentsCount = 0;

// these don't need new subclasses, but naming them differently keeps them easy to understand
typedef ComponentDataClass ErrorDataClass;
typedef ComponentDataClass WakeupSignalClass;

// declare node system devices: 0-15
NodeSystemDataClass *uptimeData;
NodeSystemDataClass *txIntervalData;
NodeSystemDataClass *rssiData;
NodeSystemDataClass *versionData;
NodeSystemDataClass *voltageData;
NodeSystemDataClass *ackData;
NodeSystemDataClass *toggleData;
NodeSystemDataClass *timerData;

// declare binary output devices (LED, relay): 16-31
DigitalOutputDataClass *actuatorData;

// declare analog output devices (pwm, dimmer): 32-39

// declare binary input devices (button, switch, PIR-sensor): 40-47
DigitalInputDataClass *buttonData;

// declare real value sensors (temperature, humidity): 48-63
RealInputDataClass *dhtTempSensorData;
RealInputDataClass *dhtHumSensorData;

// declare analog input sensors used in this node (temp, humidity): 64-71
AnalogSensorDataClass *lightSensorData;
AnalogSensorDataClass *flameSensorData;
AnalogSensorDataClass *gasSensorData;

ErrorDataClass *connectionError;
ErrorDataClass *unknownDevice;

WakeupSignalClass *wakeUp;

//
//=====================		SETUP	========================================
//
void setup() {
	// instantiate node system devices - callbacks are required
	uptimeData = new NodeSystemDataClass(UPTIMEDEVICEID, NULL, &getUptime);
	txIntervalData = new NodeSystemDataClass(TXINTERVALDEVICEID, NULL, &getTxInterval);
	rssiData = new NodeSystemDataClass(RSSIDEVICEID, NULL, &getSignalStrength);
	versionData = new NodeSystemDataClass(VERSIONDEVICEID, NULL, NULL);
	voltageData = new NodeSystemDataClass(VOLTAGEDEVICEID, NULL, &getVoltage);
	ackData = new NodeSystemDataClass(ACKDEVICEID, NULL, &getAck);
	toggleData = new NodeSystemDataClass(TOGGLEDEVICEID, NULL, &getToggleState);
	timerData = new NodeSystemDataClass(TIMERDEVICEID, NULL, &getTimerInterval);

	// instantiate binary output devices - no callback necessary
	actuatorData = new DigitalOutputDataClass(ACTUATORDEVICEID, ACT1);

	// instantiate binary input devices - no callback necessary
	int buttonDelay = 2 * 1000;
	buttonData = new DigitalInputDataClass(BTNDEVICEID, BTN, buttonDelay);

	// instantiate real data sensors - callbacks are required
	dht.begin();
	bool useFarenheit = true;
	bool forceReading = false;
	dhtTempSensorData = new RealInputDataClass(DHTTEMPDEVICEID, DHTPIN, &getDhtTemperatureFarenheit);
	dhtHumSensorData = new RealInputDataClass(DHTHUMIDITYDEVICEID, DHTPIN, &getDhtHumidity);

	// +/- this amount for each sensor triggers a transmission of data
	int lightDeltaThreshold = 50;
	int flameDeltaThreshold = 20;
	int gasDeltaThreshold = 70;

	// instantiate analog sensors - no callback required
	lightSensorData = new AnalogSensorDataClass(2 * 1000, lightDeltaThreshold, LIGHTPIN, LIGHTSENSORDEVICEID);
	flameSensorData = new AnalogSensorDataClass(2 * 1000, flameDeltaThreshold, FLAMEPIN, FLAMESENSORDEVICEID);
	gasSensorData = new AnalogSensorDataClass(5 * 1000, gasDeltaThreshold, GASPIN, GASSENSORDEVICEID);

	// instantiate error "devices" - no callback required
	connectionError = new ErrorDataClass(WIRELESSCONNECTIONERROR, NULL);
	unknownDevice = new ErrorDataClass(UNSUPPORTEDDEVICE, NULL);

	// instantiate our one wakeup device - no callback required
	wakeUp = new WakeupSignalClass(WAKEUPNODE, NULL);
	wakeUp->setShouldSend(true); //always send wakeup on first loop

#ifdef DEBUG
	Serial.begin(SERIAL_BAUD);
#endif
	radio.initialize(FREQUENCY, NODEID, NETWORKID);		// initialise radio 
#ifdef IS_RFM69HW
	radio.setHighPower(); 					// only for RFM69HW!
#endif
	radio.encrypt(ENCRYPTKEY);				// set radio encryption	`
	radio.promiscuous(promiscuousMode);			// only listen to closed network

#ifdef DEBUG
	Serial.print("Node Software Version ");
	Serial.println(VERSION);
	Serial.print("\nTransmitting at ");
	Serial.print(FREQUENCY == RF69_433MHZ ? 433 : FREQUENCY == RF69_868MHZ ? 868 : 915);
	Serial.println(" Mhz...");
#endif
}	// end setup

	//
	//
	//====================		MAIN	========================================
	//
void loop() {
	// RECEIVE radio input
	//
	if (receiveData())
	{
		parseCmd();				// receive and parse any radio input
	}
	// DETECT INPUT CHANGE
	//
	if (buttonData->getShouldSend()) 
	{			
		buttonData->setShouldSend(true);							// set button message flag
		if (buttonData->getState() == LOW) {
			if (toggleOnButton) {									// button in toggle state ?
				actuatorData->setState(!actuatorData->getState());
			}
			else if (timeInterval > 0 && !timerOnButton) {			// button in timer state ?
				timerOnButton = true;								// start timer interval
				actuatorData->setState(HIGH);
			}
		}
	}

	// TIMER CHECK
	//

	if (timeInterval > 0 && timerOnButton)			// =0 means no timer
	{
		if (millis() - buttonData->getLastInputTime() > timeInterval * 1000) {	// timer expired ?
			timerOnButton = false;				// then end timer interval 
			actuatorData->setState(LOW);
		}
	}

	// UPTIME 
	//

	// PERIODIC TRANSMISSION
	//
	/*
	if (TXinterval > 0) {
		int currPeriod = millis() / (TXinterval * 1000);
		if (currPeriod != lastPeriod) {				// interval elapsed ?
			lastPeriod = currPeriod;

			// list of sensordata to be sent periodically..
			// remove comment to include parameter in transmission

			//send1 = true;					// send transmission interval
			//send2 = true; 					// signal strength
			//send4 = true;					// voltage level
			//send16 = true;					// actuator state
			send48 = true;					// send temperature
			send49 = true;					// send humidity
		}
	}
	*/

	// POLL ANALOG SENSORS AND DETERMINE IF SHOULD SEND
	//
	for (int connectedComponentNumber = 0; connectedComponentNumber < connectedComponentsCount; connectedComponentNumber++)
	{
		connectedComponents[connectedComponentNumber]->setShouldSend(connectedComponents[connectedComponentNumber]->getShouldSend());
	}

	// SEND RADIO PACKETS
	//

	sendMsg();						// send any radio messages 

}		// end loop

		//
		//
		//=====================		FUNCTIONS	==========================================

		//
		//========		RECEIVEDATA : receive data from gateway over radio
		//

bool receiveData() {
	bool validPacket = false;
	if (radio.receiveDone()) {			// check for received packets
		if (radio.DATALEN != sizeof(mes))			// wrong message size means trouble
#ifdef DEBUG
			Serial.println("invalid message structure..")
#endif
			;
		else
		{
			mes = *(Message*)radio.DATA;
			validPacket = true;				// YES, we have a packet !
			//signalStrength = radio.RSSI;
#ifdef DEBUG
			Serial.print(mes.devID);
			Serial.print(", ");
			Serial.print(mes.cmd);
			Serial.print(", ");
			Serial.print(mes.intVal);
			Serial.print(", ");
			Serial.print(mes.fltVal);
			Serial.print(", RSSI= ");
			Serial.println(radio.RSSI);
			Serial.print("Node: ");
			Serial.println(mes.nodeID);
#endif	
		}
	}
	if (radio.ACKRequested()) radio.sendACK();		// respond to any ACK request
	return validPacket;					// return code indicates packet received
}		// end recieveData

		//
		//
		//==============		PARSECMD: analyse messages and execute commands received from gateway
		//

void parseCmd() {					// parse messages received from the gateway
	for (int connectedComponentNumber = 0; connectedComponentNumber < connectedComponentsCount; connectedComponentNumber++)
	{
		ComponentDataClass *thisDevice = connectedComponents[connectedComponentNumber];
		thisDevice->setShouldSend(false);
		if (mes.devID == thisDevice->deviceId)
		{
			if (ISNODESYSTEMDEVICE(mes.devID))
			{
				if (mes.devID == TXINTERVALDEVICEID)
				{
					if (mes.cmd == 0) {					// cmd == 0 means write a value
						
						txInterval = mes.intVal;			// change interval to radio packet value
						if (txInterval <10 && txInterval != 0) txInterval = 10;	// minimum interval is 10 seconds
						if (setAck) thisDevice->setShouldSend(true);			// send message if required
#ifdef DEBUG
						Serial.print("Setting interval to ");
						Serial.print(txInterval);
						Serial.println(" seconds");
#endif
					}
					else
					{
						thisDevice->setShouldSend(true);					// cmd == 1 is a read request, so send polling interval 
					}
				}
				else if (mes.devID == ACKDEVICEID || mes.devID == TOGGLEDEVICEID)
				{
					if (mes.cmd == 0) {
						if (mes.intVal == 0) setAck = false;
						if (mes.intVal == 1) setAck = true;
						if (setAck) thisDevice->setShouldSend(true);			// acknowledge message ?
					}
					else
					{
						thisDevice->setShouldSend(true);				// read request means schedule a message
					}
				}
				else if (mes.devID == TIMERDEVICEID)
				{
					if (mes.cmd == 0) {					// cmd == 0 means write a value
						timeInterval = mes.intVal;			// change interval 
						if (timeInterval <5 && timeInterval != 0) timeInterval = 5;
						if (setAck) thisDevice->setShouldSend(true);			// acknowledge message ?
					}							// cmd == 1 means read a value
					else
					{
						thisDevice->setShouldSend(true);				// send timing interval 
					}
				}
				else
				{
					if (mes.cmd == 1)
					{
						thisDevice->setShouldSend(true);
					}
				}
			}
			else if (ISDIGITALOUTPUTDEVICE(mes.devID))
			{
				if (mes.devID == ACTUATORDEVICEID)
				{
					if (mes.cmd == 0) {					// cmd == 0 means write
						if (mes.intVal == 0 || mes.intVal == 1) {
							actuatorData->setState(mes.intVal);
							if (setAck) actuatorData->setShouldSend(true);			// acknowledge message ?
#ifdef DEBUG	
							Serial.print("Set LED to ");
							Serial.println(actuatorData->getState());
#endif
						}
					}
					else actuatorData->setShouldSend(true);					// cmd == 1 means read
				}
			}
			else if (
				ISANALOGOUTPUTDEVICE(mes.devID) || 
				ISDIGITALINPUTSENSOR(mes.devID) || 
				ISREALINPUTSENSOR(mes.devID) ||
				ISANALOGSENSOR(mes.devID)
				)
			{
				if (mes.cmd == 1) thisDevice->setShouldSend(true);
			}
			else
			{
				unknownDevice->setShouldSend(true); // error - device wasn't recognized
			}
		}
	}
}	// end parseCmd

	//
	//
	//======================		SENDMSG: sends messages that are flagged for transmission
	//

void sendMsg() {					// prepares values to be transmitted
	//bool tx = false; 					// transmission flag
	mes.nodeID = NODEID;
	mes.intVal = 0;
	mes.fltVal = 0;
	mes.cmd = 0;						// '0' means no action needed in gateway
	int i;
	for (i = 0; i < sizeof(VERSION); i++) {
		mes.payLoad[i] = VERSION[i];
	}
	mes.payLoad[i] = '\0';					// software version in payload string

	for (int componentNumber = 0; componentNumber < connectedComponentsCount; componentNumber++)
	{
		ComponentDataClass *thisDevice = connectedComponents[componentNumber];
		if (thisDevice->getShouldSend())
		{
			mes.devID = thisDevice->deviceId;
			if (ISNODESYSTEMDEVICE(thisDevice->deviceId))
			{
				NodeSystemDataClass *nodeDevice = (NodeSystemDataClass *)thisDevice;
				mes.intVal = nodeDevice->getValueToSend();
			}
			
			if (ISDIGITALOUTPUTDEVICE(thisDevice->deviceId))
			{
				DigitalOutputDataClass *digitalOutputDevice = (DigitalOutputDataClass *)thisDevice;
				mes.intVal = digitalOutputDevice->getValueToSend();
			}

			if (ISANALOGOUTPUTDEVICE(thisDevice->deviceId))
			{
				AnalogOutputDataClass *analogOutputDevice = (AnalogOutputDataClass *)thisDevice;
				mes.intVal = analogOutputDevice->getValueToSend();
			}

			if (ISDIGITALINPUTSENSOR(thisDevice->deviceId))
			{
				DigitalInputDataClass *digitalInputDevice = (DigitalInputDataClass *)thisDevice;
				mes.intVal = digitalInputDevice->getValueToSend();
			}

			if (ISREALINPUTSENSOR(thisDevice->deviceId))
			{
				RealInputDataClass *realInputDevice = (RealInputDataClass *)thisDevice;
				mes.fltVal = realInputDevice->getValueToSend();
			}

			if (ISANALOGSENSOR(thisDevice->deviceId))
			{
				AnalogSensorDataClass *analogSensorDevice = (AnalogSensorDataClass *)thisDevice;
				mes.intVal = analogSensorDevice->getValueToSend();
			}

			if (ISERRORCODE(thisDevice->deviceId))
			{
				mes.intVal = thisDevice->deviceId;
			}

			txRadio();
		}
	}
	/*
	if (wakeUp) {						// send wakeUp call 
		mes.devID = 99;
		wakeUp = false;					// reset transmission flag for this message
		txRadio();					// transmit
	}
	if (send0) {
		mes.devID = 0;
		mes.intVal = upTime;				// minutes uptime
		send0 = false;
		txRadio();
	}
	if (send1) {						// transmission interval
		mes.devID = 1;
		mes.intVal = TXinterval;			// seconds (integer)
		send1 = false;
		txRadio();
	}
	if (send2) {
		mes.devID = 2;
		mes.intVal = signalStrength;			// signal strength (integer)
		send2 = false;
		txRadio();
	}
	if (send3) {						// node software version (string)
		mes.devID = 3;					// already stored in payload string
		send3 = false;
		txRadio();
	}
	if (send4) {						// measure voltage..
		mes.devID = 4;

		mes.fltVal = float(result / 1000.0);		// Voltage in Volt (float)
		txRadio();
		send4 = false;
	}
	if (send5) {						// Acknowledge on 'SET'
		mes.devID = 5;
		if (setAck) mes.intVal = 1; else mes.intVal = 0;// state (integer)
		send5 = false;
		txRadio();
	}
	if (send6) {						// Toggle on Buttonpress 
		mes.devID = 6;
		if (toggleOnButton) mes.intVal = 1; 		// read state of toggle flag
		else mes.intVal = 0;				// state (integer)
		send6 = false;
		txRadio();
	}
	if (send7) {						// timer interval
		mes.devID = 7;
		mes.intVal = TIMinterval;			// seconds (integer)
		send7 = false;
		txRadio();
	}
	if (send16) {						// state of Actuator 1
		mes.devID = 16;
		mes.intVal = ACT1State;				// state (integer)
		send16 = false;
		txRadio();
	}
	if (send40) {						// Binary input read
		mes.devID = 40;
		if (curState == LOW) mes.intVal = 1;					// state (integer)
		send40 = false;
		txRadio();
	}
	if (send48) {						// Temperature
		mes.devID = 48;
		temp = dht.readTemperature(true);
		mes.fltVal = temp;				// Degrees F (float)
		send48 = false;
		txRadio();
	}
	if (send49) {						// Humidity
		mes.devID = 49;
		hum = dht.readHumidity();
		mes.fltVal = hum;				// Percentage (float)
		send49 = false;
		txRadio();
	}
	if (send64) {
		mes.devID = 64;
		lightLevel = analogRead(lightLevel);
		mes.intVal = lightLevel;
		send64 = false;
		txRadio();
	}
	if (send92) {						// error message invalid device
		mes.intVal = mes.devID;
		mes.devID = 92;
		send92 = false;
		txRadio();
	}
	*/

}
//
//
//=======================		TXRADIO
//

void txRadio()						// Transmits the 'mes'-struct to the gateway
{
	if (radio.sendWithRetry(GATEWAYID, (const void*)(&mes), sizeof(mes)), 3, ACK_TIME)
#ifdef DEBUG
	{
		Serial.print(" message ");
		Serial.print(mes.devID);
		Serial.println(" sent...");
	}
	else
	{
		Serial.println("No connection...");
		Serial.println("tried to send");
		Serial.print(mes.devID);
		Serial.print(" ");
		Serial.println(mes.intVal);
	}
#endif
}	// end txRadio

// functions to use for callbacks to pass to the device classes

// number of minutes node has been running
int getUptime()
{
	return millis() / 600000;
}

int getTxInterval()
{
	return txInterval;
}

int getSignalStrength()
{
	return radio.RSSI;
}

int getVoltage()
{
	long voltage;					// Read 1.1V reference against AVcc
	ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
	delay(2);					// Wait for Vref to settle
	ADCSRA |= _BV(ADSC);				// Convert
	while (bit_is_set(ADCSRA, ADSC));
	voltage = ADCL;
	voltage |= ADCH << 8;
	voltage = 1126400L / voltage; 			// Back-calculate in mV
	return (int)(voltage / 1000.0);
}

int getAck()
{
	return setAck;
}

int getToggleState()
{
	return toggleOnButton;
}

int getTimerInterval()
{
	return timeInterval;
}

float getDhtTemperatureFarenheit()
{
	return dht.readTemperature(true);
}

float getDhtHumidity()
{
	return dht.readHumidity();
}