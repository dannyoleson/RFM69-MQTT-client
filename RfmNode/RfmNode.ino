// RFM69 node sketch
//
// This node talks to the MQTT-Gateway and will:
// - send sensor data periodically and on-demand
// - receive commands from the gateway to control actuators
// - receive commands from the gateway to change settings
//
// Several nodes can operate within a single network; each having a unique node ID.
// On startup the node operates with default values, set on compilation.
//
// Hardware used is a 3.3 Volt 8MHz arduino Pro; this is easier to interface to RFM69 
//
//
// Current defined devices are:
//
//	0	uptime:			read uptime node in minutes
//	1	node:			read/set transmission interval in seconds, 0 means no periodic transmission
//	2	RSSI:			read radio signal strength
//	3	Version:		read version node software
//	4	voltage:		read battery level
//	5	ACK:			read/set acknowledge message after a 'set' request
//	6	toggle:			read/set toggle function on button press
//	7	timer:			read/set activation timer after button press in seconds, 0 means no timer
//	
//	16	actuator:		read/set LED or relay output
//	40	Button:			tx only: message sent when button pressed
//	48	temperature:		read temperature
//	49	humidity:		read humidity
//  64  light:			read light level
//  65  flame:			read flame sensor
//	66  gas:			read gas sensor
//	90	error:			tx only: error message if no wireless connection (generated by gateway)
//	92	error:			tx only: device not supported
//	99	wakeup:			tx only: first message sent on node startup
//
// 	The button can be set to:
//	- generate a message on each press (limited to one per 10 seconds) and/or
//	- toggle the output ACT1 (local node function) or
//	- activate the output for a fixed time period (local node function)
//
//	A debug mode is included which outputs messages on the serial output
//
//	RFM69 Library by Felix Rusu - felix@lowpowerlab.com
//	Get the RFM69 library at: https://github.com/LowPowerLab/
//
//	version 1.7 by Computourist@gmail.com december 2014
//	version 2.0 increased payload size; implemented node uptime; standard device type convention; error handling .
//	version 2.1 removed device 8; changed handling of device 40; compatible with gateway V2.2	; march 2015
//  version 2.1.1 lewishollow - dannyoleson@gmail.com - Changed to OO format.  Adding/removing known devices is simple.  
//		Low power mode for batter nodes.

#include "RfmAioNodeLibrary.h"
#include <RFM69.h>
#include <RFM69_ATC.h>
#include <SPI.h>
#include <DHT.h>
#include <LowPower.h> //https://github.com/rocketscream/Low-Power/archive/master.zip

// Wireless settings	Match frequency to the hardware version of the radio
#define FREQUENCY RF69_433MHZ
//#define FREQUENCY RF69_868MHZ
//#define FREQUENCY RF69_915MHZ

#define IS_RFM69HW 					// uncomment only for RFM69HW! 
#define ONESECOND 1000

//
// CONFIGURATION PARAMETERS
//
#define NODEID 2 					// unique node ID within the closed network
#define NETWORKID 100					// network ID of the network
#define ENCRYPTKEY "xxxxxxxxxxxxxxxx" 			// 16-char encryption key; same as on Gateway!
#define DEBUG						// uncomment for debugging
//#define LOWPOWERNODE				// uncomment for battery-powered node

//
// ENABLE OR DISABLE DEVICES HERE
//
#define PHOTOSENSORENABLED
#define REEDSWITCHENABLED
//#define BUTTONENABLED
#define PIRENABLED
#define FLAMESENSORENABLED
#define GASSENSORENABLED
#define DHTSENSORENABLED

// TO ADD DEVICES, DECLARE THEM BELOW ALONG WITH NECESSARY DATA AS INDICATED BY THE CLASS
// USING A DEFINE FOR EACH DEVICE BEING ENABLED IS WHAT ALLOWS THIS CODE TO WORK ON A DEVICE
// WITH ANY SET OF SENSORS

// DO NOT MODIFY THIS SET OF SYSTEM DEVICES
NodeSystemDataClass *uptimeData;
NodeSystemDataClass *txIntervalData;
NodeSystemDataClass *rssiData;
NodeSystemDataClass *versionData;
NodeSystemDataClass *voltageData;
NodeSystemDataClass *ackData;
NodeSystemDataClass *toggleData;
NodeSystemDataClass *timerData;

ErrorDataClass *connectionError;
ErrorDataClass *unknownDevice;

WakeupSignalClass *wakeUp;
//END SYSTEM DEVICES

// Binary input settings
#ifdef BUTTONENABLED
#define BTN 8	// Button pin
#define BTNDEVICEID 40
DigitalInputDataClass *buttonData;
#endif //BUTTONENABLED

#ifdef REEDSWITCHENABLED
#define REEDSWITCHPIN 3
#define REEDSWITCHDEVICEID 42
DigitalInputDataClass *reedSwitchData;
#endif //REEDSWITCHENABLED

// Binary output settings
#ifdef ACTUATORENABLED
#define ACT1 9	// Actuator pin (LED or relay)
#define ACTUATORDEVICEID 16
DigitalOutputDataClass *actuatorData;
#endif //ACTUATORENABLED

#ifdef PIRENABLED
#define PIRPIN 8
#define PIRDEVICEID 41
DigitalInputDataClass *pirData;
#endif

// Analog sensor settings
#ifdef PHOTOSENSORENABLED
#define LIGHTPIN A0
#define LIGHTSENSORDEVICEID 64
AnalogSensorDataClass *lightSensorData;
#endif //PHOTOSENSORENABLED

#ifdef FLAMESENSORENABLED
#define FLAMEPIN A1
#define FLAMESENSORDEVICEID 65
AnalogSensorDataClass *flameSensorData;
#endif //FLAMESENSORENABLED

#ifdef GASSENSORENABLED
#define GASPIN A2
#define GASSENSORDEVICEID 66
AnalogSensorDataClass *gasSensorData;
#endif //GASSENSORENABLED

// DHT sensor setting
#ifdef DHTSENSORENABLED
#define DHTPIN 4					// DHT data connection
#define DHTTEMPDEVICEID 48
#define DHTHUMIDITYDEVICEID 49
#define	DHTTYPE	DHT22	// type of sensor

DHT dht(DHTPIN, DHTTYPE, 3);			// initialise temp/humidity sensor for 3.3 Volt arduino
//DHT dht(DHTPIN, DHTTYPE);				// 5 volt power

RealInputDataClass *dhtTempSensorData;
RealInputDataClass *dhtHumSensorData;
#endif //DHTSENSORENABLED

//
// END DEVICE DECLARATION

//if using buttons, you can change behavior here
long	timeInterval = 20 * ONESECOND;				// timer interval in ms
bool	toggleOnButton = true;				// toggle output on button press

// DO NOT MODIFY THE REST OF THIS HEADER UNTIL THE SETUP FUNCTION
bool	setAck = false;					// send ACK message on 'SET' request
bool	promiscuousMode = false; 			// only listen to nodes within the closed network

#ifdef LOWPOWERNODE
long numWakes = 0;
long thisCycleActualMillis;
#endif

// use this instead of millis() - it allows the low power mode to still track time.  Sort of.
unsigned long currentTime;

Message mes;
RFM69_ATC radio;

// adding components in setup() will add to this array and increment the count
ComponentDataClass *connectedComponents[100];
int connectedComponentsCount = 0;

//
//=====================		SETUP	========================================
//
void setup() 
{
	// DO NOT MODIFY THE BELOW CODE UNTIL INDICATED
	//
	// instantiate node system devices
	uptimeData = new NodeSystemDataClass(UPTIMEDEVICEID, NULL, &getUptime);
	txIntervalData = new NodeSystemDataClass(TXINTERVALDEVICEID, NULL, &getTxInterval);
	rssiData = new NodeSystemDataClass(RSSIDEVICEID, NULL, &getSignalStrength);
	versionData = new NodeSystemDataClass(VERSIONDEVICEID, NULL, NULL);
	voltageData = new NodeSystemDataClass(VOLTAGEDEVICEID, NULL, &getVoltage);
	ackData = new NodeSystemDataClass(ACKDEVICEID, NULL, &getAck);
#ifdef LOWPOWERNODE
	//pinMode(REEDSWITCHPIN, INPUT);
	// if running on low power, you won't be able to query.  These will always send their status ever txInterval seconds
	uptimeData->periodicSendEnabled = true;
	rssiData->periodicSendEnabled = true;
	voltageData->periodicSendEnabled = true;
#endif //LOWPOWERNODE

	// instantiate error devices
	connectionError = new ErrorDataClass(WIRELESSCONNECTIONERROR, NULL);
	unknownDevice = new ErrorDataClass(UNSUPPORTEDDEVICE, NULL);

	// instantiate our one wakeup device - DO NOT MODIFY
	wakeUp = new WakeupSignalClass(WAKEUPNODE, NULL);
	wakeUp->setShouldSend(true); //always send wakeup on first loop

	toggleData = new NodeSystemDataClass(TOGGLEDEVICEID, NULL, &getToggleState);
	timerData = new NodeSystemDataClass(TIMERDEVICEID, NULL, &getTimerInterval);
	//
	// MODIFY BELOW THIS POINT

	// instantiate binary output devices - DO NOT MODIFY
#ifdef ACTUATORENABLED
	actuatorData = new DigitalOutputDataClass(ACTUATORDEVICEID, ACT1);
#endif //ACTUATORENABLED

#ifdef ACT1ENABLED
	actuator1Data = new DigitalOutputDataClass(ACT1DEVICEID, ACT1PIN);
#endif

#ifdef ACT2ENABLED
	actuator2Data = new DigitalOutputDataClass(ACT2DEVICEID, ACT2PIN);
#endif

#ifdef PIRENABLED
	pirData = new DigitalInputDataClass(PIRDEVICEID, PIRPIN, ONESECOND);
#endif

	// instantiate binary input devices - DO NOT MODIFY
#ifdef BUTTONENABLED
	int buttonDelay = 2 * ONESECOND;
	buttonData = new DigitalInputDataClass(BTNDEVICEID, BTN, buttonDelay);
#endif //BUTTONENABLED

#ifdef REEDSWITCHENABLED
	reedSwitchData = new DigitalInputDataClass(REEDSWITCHDEVICEID, REEDSWITCHPIN, 10);
	reedSwitchData->periodicSendEnabled = true;
#endif //REEDSWITCHENABLED

	// instantiate real data sensors - callbacks are required
#ifdef DHTSENSORENABLED	
	dht.begin();
	bool useFarenheit = true;
	bool forceReading = false;
	long overrideTxInterval = 30 * ONESECOND;
	dhtTempSensorData = new RealInputDataClass(DHTTEMPDEVICEID, DHTPIN, overrideTxInterval, &getDhtTemperatureFarenheit);
	dhtHumSensorData = new RealInputDataClass(DHTHUMIDITYDEVICEID, DHTPIN, overrideTxInterval, &getDhtHumidity);
#endif //DHTSENSORENABLED

	// instantiate analog sensors - no callback required
#ifdef PHOTOSENSORENABLED
	int lightDeltaThreshold = 50;
	lightSensorData = new AnalogSensorDataClass(2 * ONESECOND, lightDeltaThreshold, LIGHTPIN, LIGHTSENSORDEVICEID);
	lightSensorData->periodicSendEnabled = true;
#endif //PHOTOSENSORENABLED

#ifdef FLAMESENSORENABLED
	int flameDeltaThreshold = 20;
	flameSensorData = new AnalogSensorDataClass(2 * ONESECOND, flameDeltaThreshold, FLAMEPIN, FLAMESENSORDEVICEID);
	flameSensorData->periodicSendEnabled = true;
#endif //FLAMESENSORENABLED
	
#ifdef GASSENSORENABLED
	int gasDeltaThreshold = 70;
	gasSensorData = new AnalogSensorDataClass(5 * ONESECOND, gasDeltaThreshold, GASPIN, GASSENSORDEVICEID);
	gasSensorData->periodicSendEnabled = true;
#endif //GASSENSORENABLED

#ifdef DEBUG
	Serial.begin(SERIAL_BAUD);
#endif
	radio.initialize(FREQUENCY, NODEID, NETWORKID);		// initialise radio 
#ifdef IS_RFM69HW
	radio.setHighPower(); 					// only for RFM69HW!
#endif
	radio.encrypt(ENCRYPTKEY);				// set radio encryption	`
	radio.promiscuous(promiscuousMode);			// only listen to closed network

	radio.enableAutoPower(-90);

#ifdef DEBUG
	Serial.print("Node Software Version ");
	Serial.println(VERSION);
	Serial.print("\nTransmitting at ");
	Serial.print(FREQUENCY == RF69_433MHZ ? 433 : FREQUENCY == RF69_868MHZ ? 868 : 915);
	Serial.println(" Mhz...");
#endif
}	// end setup

//
//
//====================		MAIN	========================================
//
void loop() 
{
#ifdef LOWPOWERNODE
	radio.sleep();
	LowPower.powerDown(SLEEP_2S, ADC_OFF, BOD_OFF);
	thisCycleActualMillis = millis();
	numWakes++;
	// when using low power, we can approximate actual time by adding millis()
	// to the number of times we've woken up multiplied by the amount of time we have been sleeping
	// it appears there is -~8% error to this, though, so we're making up for that by adding
	// 8% of sleep time (first arg to powerDown)
	int errorCorrection = 180; 
	currentTime =  millis() + (numWakes * ((2 * ONESECOND) + 160));
	delay(500);
#else
	// RECEIVE radio input
	if (receiveData())
	{
		parseCmd();				// receive and parse any radio input
	}
	currentTime = millis();
#endif

	// find buttons and handle their timers appropriately
	for (int componentNum = 0; componentNum < connectedComponentsCount; componentNum++)
	{
		if (ISDIGITALINPUTSENSOR(componentNum))
		{
			DigitalInputDataClass *thisDigitalInput = (DigitalInputDataClass *)connectedComponents[componentNum];
			if (thisDigitalInput->getIsButton())
			{
				thisDigitalInput->handleInput();
				thisDigitalInput->handleTimer();
			}
		}
	}

	// SEND RADIO PACKETS
	sendMsg();
}		// end loop

//
//
//=====================		FUNCTIONS	==========================================

//
//========		RECEIVEDATA : receive data from gateway over radio
//

bool receiveData() 
{
	bool validPacket = false;
	if (radio.receiveDone()) // check for received packets
	{			
		validPacket = radio.DATALEN == sizeof(mes);
		if (validPacket)
		{
			mes = *(Message*)radio.DATA;
			validPacket = true;				// YES, we have a packet !
		}

#ifdef DEBUG
		if (!validPacket)
		{
			Serial.println("invalid message structure..");
		}
		else
		{
			Serial.print(mes.devID);
			Serial.print(", ");
			Serial.print(mes.cmd);
			Serial.print(", ");
			Serial.print(mes.intVal);
			Serial.print(", ");
			Serial.print(mes.fltVal);
			Serial.print(", RSSI= ");
			Serial.println(radio.RSSI);
			Serial.print("Node: ");
			Serial.println(mes.nodeID);
		}
#endif
	}

	if (radio.ACKRequested())
	{
		radio.sendACK();		// respond to any ACK request
	}

	return validPacket;					// return code indicates packet received
}		// end recieveData

//
//
//==============		PARSECMD: analyse messages and execute commands received from gateway
//

void parseCmd() 
{					// parse messages received from the gateway
	bool deviceFound = false;
	for (int connectedComponentNumber = 0; connectedComponentNumber < connectedComponentsCount; connectedComponentNumber++)
	{
		ComponentDataClass *thisDevice = connectedComponents[connectedComponentNumber];
		thisDevice->setShouldSend(false);
		if (mes.devID == thisDevice->deviceId)
		{
			Serial.println(mes.devID);
			deviceFound = true;

			if (mes.cmd == READ)
			{
				thisDevice->setShouldSend(true);
			}

			if (ISNODESYSTEMDEVICE(mes.devID))
			{
				if (mes.devID == TXINTERVALDEVICEID)
				{
					if (mes.cmd == WRITE) // cmd == 0 means write a value
					{	
						thisDevice->setShouldSend(setAck);
						// change interval to radio packet value - min value is 10
						for (int deviceNum = 0; deviceNum < connectedComponentsCount; deviceNum++)
						{
							mes.intVal < 10 ? connectedComponents[deviceNum]->txInterval = 10
								: connectedComponents[deviceNum]->txInterval = mes.intVal;
						}

#ifdef DEBUG
						Serial.print("Setting interval to ");
						Serial.print(mes.intVal);
						Serial.println(" seconds");
#endif
					}
				}
				else if (mes.devID == ACKDEVICEID)
				{
					if (mes.cmd == WRITE) 
					{
						// intVal will indicate whether or not to acknowledge
						// for safety, ensure it's 1 or 0
						setAck = !(!(mes.intVal));
						thisDevice->setShouldSend(setAck);			// acknowledge message ?
					}
				}
				else if (mes.devID == TOGGLEDEVICEID)
				{
					if (mes.cmd == WRITE) 
					{
						toggleOnButton = !(!(mes.intVal));
						if (setAck)
						{
							thisDevice->setShouldSend(true);			// acknowledge message ?
						}
					}
				}
				else if (mes.devID == TIMERDEVICEID)
				{
					if (mes.cmd == WRITE) 
					{
						timeInterval = mes.intVal;			// change interval 
						if (timeInterval < 5 && timeInterval != 0)
						{
							timeInterval = 5;
						}
						thisDevice->setShouldSend(setAck);			// acknowledge message ?
					}							// cmd == 1 means read a value
				}
			}
			else if (ISDIGITALOUTPUTDEVICE(mes.devID))
			{
				if (mes.cmd == 0) // cmd == 0 means write 
				{					
					if (mes.intVal == 0 || mes.intVal == 1) 
					{
						DigitalOutputDataClass *digitalOutput;
						for (int componentNum = 0; componentNum < connectedComponentsCount; componentNum++)
						{
							if (connectedComponents[componentNum]->deviceId == mes.devID)
							{
								digitalOutput = (DigitalOutputDataClass *)connectedComponents[componentNum];
							}
						}
						digitalOutput->setState(mes.intVal);
						digitalOutput->setShouldSend(setAck);			// acknowledge message ?
					}
				}
			}
		}
	}
	if (!deviceFound)
	{
		unknownDevice->setShouldSend(true);
	}
}	// end parseCmd

//
//
//======================		SENDMSG: sends messages that are flagged for transmission
//

void sendMsg() 
{					
	mes.nodeID = NODEID;
	mes.intVal = 0;
	mes.fltVal = 0;
	mes.cmd = 0;						// '0' means no action needed in gateway
	int i;
	for (i = 0; i < sizeof(VERSION); i++) {
		mes.payLoad[i] = VERSION[i];
	}
	mes.payLoad[i] = '\0';					// software version in payload string

	if (wakeUp->getShouldSend())
	{
		mes.devID = wakeUp->deviceId;
		txRadio();
		wakeUp->setShouldSend(false);
	}

	for (int componentNumber = 0; componentNumber < connectedComponentsCount; componentNumber++)
	{	
		if (ISNODESYSTEMDEVICE(connectedComponents[componentNumber]->deviceId))
		{
			NodeSystemDataClass *nodeDevice = (NodeSystemDataClass *)connectedComponents[componentNumber];
			if (nodeDevice->getShouldSend())
			{
				mes.devID = nodeDevice->deviceId;
				// node devices can be floats or ints - setting both to catch all
				mes.fltVal = nodeDevice->getValueToSend();
				mes.intVal = (int)nodeDevice->getValueToSend();
				txRadio();
				nodeDevice->setShouldSend(false);
			}
		}

		if (ISDIGITALOUTPUTDEVICE(connectedComponents[componentNumber]->deviceId))
		{
			DigitalOutputDataClass *digitalOutputDevice = (DigitalOutputDataClass *)connectedComponents[componentNumber];
			if (digitalOutputDevice->getShouldSend())
			{
				mes.devID = digitalOutputDevice->deviceId;
				mes.intVal = digitalOutputDevice->getValueToSend();
				txRadio();
				digitalOutputDevice->setShouldSend(false);
			}		
		}

		if (ISANALOGOUTPUTDEVICE(connectedComponents[componentNumber]->deviceId))
		{
			AnalogOutputDataClass *analogOutputDevice = (AnalogOutputDataClass *)connectedComponents[componentNumber];
			if (analogOutputDevice->getShouldSend())
			{
				mes.devID = analogOutputDevice->deviceId;
				mes.intVal = analogOutputDevice->getValueToSend();
				txRadio();
				analogOutputDevice->setShouldSend(false);
			}		
		}

		if (ISDIGITALINPUTSENSOR(connectedComponents[componentNumber]->deviceId))
		{
			DigitalInputDataClass *digitalInputDevice = (DigitalInputDataClass *)connectedComponents[componentNumber];
			if (digitalInputDevice->getShouldSend())
			{
				mes.devID = digitalInputDevice->deviceId;
				mes.intVal = digitalInputDevice->getValueToSend();
				txRadio();
				digitalInputDevice->setShouldSend(false);
			}
		}

		if (ISREALINPUTSENSOR(connectedComponents[componentNumber]->deviceId))
		{
			RealInputDataClass *realInputDevice = (RealInputDataClass *)connectedComponents[componentNumber];
			if (realInputDevice->getShouldSend())
			{
				mes.devID = realInputDevice->deviceId;
				mes.fltVal = realInputDevice->getValueToSend();
				txRadio();
				realInputDevice->setShouldSend(false);
			}
		}

		if (ISANALOGSENSOR(connectedComponents[componentNumber]->deviceId))
		{
			AnalogSensorDataClass *analogSensorDevice = (AnalogSensorDataClass *)connectedComponents[componentNumber];
			if (analogSensorDevice->getShouldSend())
			{
				mes.devID = analogSensorDevice->deviceId;
				mes.intVal = analogSensorDevice->getValueToSend();
				txRadio();
				analogSensorDevice->setShouldSend(false);
			}
		}

		if (ISERRORCODE(connectedComponents[componentNumber]->deviceId))
		{
			if (connectedComponents[componentNumber]->getShouldSend())
			{
				mes.intVal = mes.devID;
				mes.devID = connectedComponents[componentNumber]->deviceId;
				txRadio();
				connectedComponents[componentNumber]->setShouldSend(false);
			}
		}

		if (ISWAKEUPCODE(connectedComponents[componentNumber]->deviceId))
		{
			if (connectedComponents[componentNumber]->getShouldSend())
			{
				mes.devID = connectedComponents[componentNumber]->deviceId;
				txRadio();
				connectedComponents[componentNumber]->setShouldSend(false);
			}
		}
	}
}

//
//
//=======================		TXRADIO
//

void txRadio()						// Transmits the 'mes'-struct to the gateway
{
	if (radio.sendWithRetry(GATEWAYID, (const void*)(&mes), sizeof(mes), 5, ACK_TIME))
#ifdef DEBUG
	{
		Serial.print(" message ");
		Serial.print(mes.devID);
		Serial.println(" sent...");
	}
	else
	{
		Serial.println("No connection...");
	}
#endif
}	// end txRadio

//
//
//==============	functions to use for callbacks to pass to the device classes
//
// 

float getUptime()
{
	return currentTime / 60000;
}

float getTxInterval()
{
	int returnValue = -1;
	if (connectedComponentsCount > 0)
	{
		returnValue = connectedComponents[0]->txInterval;
	}
	return returnValue;
}

float getSignalStrength()
{
	return radio.RSSI;
}

float getVoltage()
{
	long voltage;					// Read 1.1V reference against AVcc
	ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
	delay(2);						// Wait for Vref to settle
	ADCSRA |= _BV(ADSC);			// Convert
	while (bit_is_set(ADCSRA, ADSC));
	voltage = ADCL;
	voltage |= ADCH << 8;
	voltage = 1126400L / voltage; 	// Back-calculate in mV
	return float(voltage / 1000.0);
}

float getAck()
{
	return setAck * 1.0;
}

float getToggleState()
{
	return (float)toggleOnButton;
}

float getTimerInterval()
{
	return (float)timeInterval;
}

#ifdef DHTSENSORENABLED
float getDhtTemperatureFarenheit()
{
	return dht.readTemperature(true);
}

float getDhtHumidity()
{
	return dht.readHumidity();
}
#endif //DHTSENSORENABLED